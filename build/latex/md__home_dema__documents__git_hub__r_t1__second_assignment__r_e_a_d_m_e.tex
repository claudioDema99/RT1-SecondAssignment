Demaria Claudio (S5433737)\hypertarget{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md1}{}\doxysection{Description}\label{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md1}
In this assignment, we are going to use {\bfseries{ROS}} (Robot Operating System) in order to control a mobile robot in a 3D simulation environment called {\itshape Gazebo}. ~\newline
 It was provided to us an implementation of an action server that moves a robot in the environment by implementing the {\itshape bug0} algorithm. ~\newline
 We have been provided with a package containing basically three ROS nodes\+:
\begin{DoxyItemize}
\item {\ttfamily bug\+\_\+as.\+py}\+: an action server node that, once received the desired position, calls the needed services to bring the robot to the desired position, setting the position as a ROS parameter;
\item {\ttfamily go\+\_\+to\+\_\+point\+\_\+service.\+py} is the service node that, when called, makes the robot move toward the desired position, retrieved from the ROS parameter;
\item {\ttfamily wall\+\_\+follow\+\_\+service.\+py} is the service node that, when called, makes the robot move around an obstacle (a wall, an object...);
\end{DoxyItemize}

In order to control the robot inside the simulation, we were asked to implement three nodes. ~\newline
 The {\bfseries{first node}} should allow the user to set the desired position of the robot inside of the arena or to stop the robot. ~\newline
 The {\bfseries{second node}} is a service and, when called, should print the number of positions reached and how many times the robot has been stopped. ~\newline
 The {\bfseries{third node}} should print the distance of the robot from the desired position and its average speed.\hypertarget{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md2}{}\doxysection{Logic of the program}\label{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md2}
When the launch file is executed, in addition to {\itshape Rviz} and {\itshape Gazebo}, three more screens are opened\+: one showing the {\itshape \mbox{\hyperlink{namespaceclient__publisher}{client\+\_\+publisher}}} node output, another printing the {\itshape subscriber} node information, and the last printing the {\itshape service} node information. ~\newline
 Initially in the {\itshape \mbox{\hyperlink{namespaceclient__publisher}{client\+\_\+publisher}}} window (that will be our main interaction window with the program), the program asks the user to provide a set of coordinates (x,y) to define the target position. ~\newline
 The robot starts moving, and while the robot is moving the user can enter a {\ttfamily c} character, in order to cancel the goal position. If the user lets the robot reach the desired position, a {\itshape goal position reached} string is shown and on the {\itshape service} screen are printed the updated information about the number of goals reached/canceled. ~\newline
 At this point, always in the same {\itshape \mbox{\hyperlink{namespaceclient__publisher}{client\+\_\+publisher}}} window, the program asks if the robot wants to reach another position, and the user can reply {\itshape yes}, or {\itshape no} (Y/n). ~\newline
 If the user agrees, the program restarts asking for a new set of desired coordinates. ~\newline
 Otherwise, the program kills all the nodes and prints a {\itshape goodbye message}. ~\newline
 If the user wants to cancel the target when the robot is moving toward the desired position, the user can enter {\ttfamily c} and the robot is immediately stopped, a {\itshape goal canceled string} is printed and on the {\itshape service} screen are showed the updated information about the number of goals reached/canceled. ~\newline
 During all these steps, on the {\itshape subscriber} screen are continuously printed the distance between the robot and the target, and the average velocity of the robot, at the frequency set in the launch file. ~\newline
 $<$figure$>$  $<$/figure$>$ ~\newline


{\bfseries{Goodbye message and killing all nodes}}

$<$figure$>$  $<$/figure$>$ ~\newline
\hypertarget{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md3}{}\doxysection{My added nodes}\label{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md3}

\begin{DoxyItemize}
\item {\ttfamily client\+\_\+publisher.\+py}\+: this node implements a client, a publisher and two subscribers (the name was given at the beginning of my work, only later I discover that the node would also be a subscriber..). ~\newline
 We have to publish a custom message containing the robot position and velocity, so we subscribe to the {\ttfamily \textbackslash{}odom} topic\+: in the callback, we calculate position and velocity, and we also publish the custom message with the (global) publisher. ~\newline
 All the logic of the program is contained inside the {\itshape target\+\_\+goal()} function. ~\newline
 We have three states\+: in the {\bfseries{first state}}, the program asks the user to provide a set of coordinates (x,y) to define the target position, and send the goal to the action server so the robot starts moving. In the {\bfseries{second state}} the user can cancel the goal (entering a {\ttfamily c} character) or let the robot reach the desired position\+: in both cases, the custom server will be called at the end printing the updated number of goals reached/cancelled. In the {\bfseries{third state}} the program asks if the robot wants to reach another position\+: if the user wants, the program asks for another set of coordinates to reach, otherwise the program kills all the nodes and prints a {\itshape goodbye message}. ~\newline
 In order to know if the robot has reached the desired position, we need an other subscriber\+: we subscribe to the {\ttfamily reaching\+\_\+goal\textbackslash{}result} topic of the action server and we manage a boolean flag properly in order to know if the robot has reached the goal.
\item {\ttfamily subscriber.\+py}\+: this node implements a subscriber to our custom message and in the callback, it calculates the distance from the desired position and the average speed and it prints these informations at an established frequency, given as a paramether by the launch file.
\item {\ttfamily service.\+py}\+: this node implements a custom service that prints the number of goals reached/cancelled. ~\newline
 In order to know if the robot has reached the goal position, the node has to subscribe to the {\ttfamily reaching\+\_\+goal\textbackslash{}result} topic of the action server. ~\newline

\end{DoxyItemize}

{\bfseries{Flowchart of the \textquotesingle{}client\+\_\+publisher.\+py\textquotesingle{} node}} $<$figure$>$  $<$/figure$>$\hypertarget{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md4}{}\doxysection{My custom message and service}\label{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md4}
I have defined a custom message for the {\ttfamily \textbackslash{}my\+\_\+pos\+\_\+vel} topic and a {\ttfamily Goals\+\_\+number.\+srv} service, contained respectively within the {\ttfamily \textbackslash{}msg} and {\ttfamily \textbackslash{}srv} folder. ~\newline


{\bfseries{Custom message}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{float64 x}
\DoxyCodeLine{float64 y}
\DoxyCodeLine{float64 vel\_x}
\DoxyCodeLine{float64 vel\_y}

\end{DoxyCode}
 {\bfseries{Custom service}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\# Request}
\DoxyCodeLine{int32 input}
\DoxyCodeLine{-\/-\/-\/}
\DoxyCodeLine{\# Response}
\DoxyCodeLine{int32 reached}
\DoxyCodeLine{int32 cancelled}

\end{DoxyCode}
\hypertarget{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md5}{}\doxysection{Install and run}\label{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md5}
First of all, you need to run the master by typing\+: \begin{DoxyVerb}roscore
\end{DoxyVerb}
 To install the module, you need to go inside the {\ttfamily src} folder of your ROS workspace and run the following command\+: \begin{DoxyVerb}git clone https://github.com/claudioDema99/RT1-SecondAssignment
\end{DoxyVerb}
 and from the root directory of your ROS workspace run the command\+: \begin{DoxyVerb}catkin_make
\end{DoxyVerb}
 To run the program, you need to have installed in your system the program {\bfseries{xterm}}. To install it, run\+: \begin{DoxyVerb}sudo apt-get install xterm
\end{DoxyVerb}
 Finally, to run the code, type the following command\+: \begin{DoxyVerb}roslaunch assignment_2_2022 assignment1.launch
\end{DoxyVerb}
 \hypertarget{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md6}{}\doxysection{Possible improvements}\label{md__home_dema__documents__git_hub__r_t1__second_assignment__r_e_a_d_m_e_autotoc_md6}
The first thing you notice when running the program is that when a desired position is entered, it is not clear where in the arena this point is\+: we can simply put a marker inside the arena simulation in order to make this clear. ~\newline
 In this way the user can also notice if the entered position is involuntarily near or inside a wall. ~\newline
 Another possible improvement is modifying the algorithm that control the movement of the robot, because it seems to be very basic. For example, if the robot finds a wall while moving to the desired position, it overcomes it always going around it clockwise, sometimes getting further from the goal. 